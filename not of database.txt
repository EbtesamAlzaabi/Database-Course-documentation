q1)

| **Structure**       | Single file/table (e.g., CSV, TXT). Simple rows and columns with minimal enforced schema.                 | Multiple related tables with defined schemas, data types, and constraints.                                                 |
| **Data Redundancy** | High redundancy; same data often repeated due to lack of normalization.                                   | Low redundancy through normalization and relational design.                                                                |
| **Relationships**   | No native support for relationships; must be handled manually in application logic.                       | Built-in relationship support (1:1, 1:N, N:N) using primary/foreign keys and referential integrity.                        |
| **Example Usage**   | Configuration files, logs, spreadsheets, small/simple data storage.                                       | Enterprise systems (CRM, ERP), web apps, banking systems, analytics and reporting.                                         |
| **Drawbacks**       | Poor scalability, high redundancy, weak data integrity, no concurrency control, slow for complex queries. | Requires more resources, setup, and management; strict schema can reduce flexibility; may be excessive for small datasets. |

q3:
| **System Analyst**               | Gathers business requirements, analyzes processes, and defines system specifications. Acts as a bridge between users and technical teams to ensure the database system meets business needs. 
|
| **Database Designer**            | Designs the database structure, including data models, entities, relationships, normalization, and schema. Ensures the design su
pports integrity, performance, and scalability.              |

| **Database Developer**           | Implements the database design by creating tables, views, stored procedures, triggers, and indexes. Writes and optimizes SQL to ensure correct and efficient operations.                     |

| **DBA (Database Administrator)** | Manages the database environment: performance tuning, backups, recovery, security, user access, monitoring, and ensuring availability. Maintains and optimizes the database over time.       |

| **Application Developer**        | Builds applications that interact with the database. Writes code to retrieve, process, and update data using APIs or SQL. Ensures smooth communication between the app and the database.     |

| **BI Developer**                 | Transforms raw data into analytics and reports. Builds dashboards, ETL/ELT pipelines, and data models. Works with data warehouses to support business decision-making.                       |

Additional Research Topics to Include in the Report:
1. Types of Databases:
 
| Type                       | Description                                                                   | Examples                                                                      | Typical Use Cases                                                            |
| | 
| **Relational (SQL)**       | Structured tables, ACID transactions, uses SQL, strict schemas.               | SQL Server, MySQL, PostgreSQL, Oracle                                         | Banking, ERP, financial systems, inventory, apps needing strong consistency. |
| **Non-Relational (NoSQL)** | Flexible schemas, handles unstructured/semi-structured data, highly scalable. | MongoDB (Document), Cassandra (Wide-column), Redis (Key-value), Neo4j (Graph) | Social networks, IoT, real-time analytics, logging, scalable web apps.       |

Centralized vs Distributed vs Cloud Databases

| Type            | Description                                      | Pros                                                | Cons                                                  | Use Cases                                              |
| |
| **Centralized** | All data stored on one server/location.          | Simple to manage, secure locally.                   | Single point of failure, limited scalability.         | Small businesses, standalone systems.                  |
| **Distributed** | Data split across multiple nodes/locations.      | High availability, fault tolerance, scalable.       | More complex to manage, network dependency.           | Global apps, high-traffic websites, large enterprises. |
| **Cloud**       | Hosted by cloud providers; scalable and managed. | Auto-scaling, backups, global reach, pay-as-you-go. | Subscription cost, internet required, vendor lock-in. | Modern web apps, SaaS platforms, mobile backends.      |

Cloud Database Advantages vs Disadvantages
| Advantages                  | Disadvantages                      |
| --------------------------- | ---------------------------------- |
| Auto-scaling                | Requires internet                  |
| Automatic backups & updates | Ongoing subscription cost          |
| High availability           | Vendor lock-in                     |
| Easy global replication     | Compliance/security considerations |

3. Database Engines and Languages

| Concept             | Description                                                                             |
| **Database Engine** | The core software that manages storage, queries, indexing, transactions, and retrieval. |

Database Engines and Their Languages

| Database Engine  | Type                | Primary Query Language      |
| ---------------- | ------------------- | --------------------------- |
| SQL Server       | Relational          | **T-SQL**                   |
| Oracle Database  | Relational          | **PL/SQL**                  |
| MySQL            | Relational          | ANSI SQL (MySQL extensions) |
| PostgreSQL       | Relational          | ANSI SQL + **PL/pgSQL**     |
| MongoDB Engine   | NoSQL (Document)    | **MQL**                     |
| Cassandra Engine | NoSQL (Wide-column) | **CQL**                     |

‚úÖ Is Migration Between Engines Possible?

Yes.

Tools exist to help automate migration from one engine to another. For example, Oracle SQL Developer supports migrating third-party databases (like SQL Server, MySQL etc.) into Oracle: it reads the source database schema, builds a ‚Äúcaptured model,‚Äù converts it to an Oracle schema, then migrates data. 
Oracle Documentation

Similarly, migration from Oracle ‚Üí PostgreSQL (or other open-source engines) is well-supported by migration services and tools. 
Google Cloud
+2
Amazon Web Services, Inc.
+2

So in principle ‚Äî yes, migration is possible and regularly done.

‚ö†Ô∏è Challenges of Engine-to-Engine Migration

However, moving between different database engines presents multiple challenges. Some of the common issues:

Data type mismatches / incompatibilities: Different engines support different data types (e.g., numeric precision/scale, BLOB/CLOB, date/time types, text encodings). Something supported in the source might not map cleanly to a destination type, risking data loss or truncation. 
Essential Designs
+2
DB Cloning & Virtual Admin
+2

Procedural code (stored procedures, triggers, functions): Business logic embedded in stored procedures/triggers often relies on the engine‚Äôs proprietary dialect (e.g. T-SQL in SQL Server, PL/SQL in Oracle). Those do not port directly to another engine‚Äôs procedural language (e.g. PL/pgSQL in PostgreSQL). They often must be rewritten. 
Convert-In
+2
DB Cloning & Virtual Admin
+2

Differences in SQL dialect / syntax: Even for simple queries, syntax differences (e.g. identifier quoting, functions, date/time manipulation, limit/offset vs TOP, etc.) may require rewriting queries. 
USAVPS
+2
LinkedIn
+2

Schema differences ‚Äî constraints, default values, identity / auto-increment columns, indexing, partitions, proprietary features: For example, what is supported in one engine (special index types, partitioning, proprietary features) might not exist in another, or behave differently. 
AWS Documentation
+2
DataStrike
+2

Application-level dependencies: Applications tied to a specific engine ‚Äî e.g. using engine-specific features, client drivers, error codes, or behavior ‚Äî may break or need refactoring after migration. 
Amazon Web Services, Inc.
+2
Ericks Webs Design
+2

Potential data integrity, performance, or behavior differences: Even if things migrate, the way queries are optimized, index behavior, transaction handling, and concurrency can differ ‚Äî meaning performance tuning and testing are required after migration. 
Ralan Tech
+2
Convert-In
+2

Downtime and complexity: For large databases, migration can be a complex, time-consuming process ‚Äî downtime may be required, and verifying data consistency/integrity is non-trivial. 
Ralan Tech
+1

üìã What to Consider / Prepare Before Migration

If you plan to transfer a database from one engine to another, you should carefully review and plan for:

Data Types ‚Äî map each source column type to an appropriate destination type, handle precision/scale, character sets, BLOBs/CLOBs, date/time, etc.

Schema & Constraints ‚Äî primary keys, foreign keys, indexes, default values, uniqueness, auto-increment/identity columns vs sequences.

Stored Procedures, Triggers, Functions, Business Logic in Database ‚Äî identify all procedural code, review for engine-specific syntax or behavior, plan to rewrite or adapt to target engine‚Äôs language (e.g. PL/pgSQL instead of PL/SQL or T-SQL).

Queries and SQL Syntax Differences ‚Äî adjust queries, views, scripts, ORMs, and test them thoroughly.

Application Layer ‚Äî update database connection code, drivers, handle differences in behavior (error handling, data return formats, transactions, collation/encoding).

Performance & Indexing Strategies ‚Äî re-evaluate indexes, query plans, possibly redesign for target engine‚Äôs optimizer.

Testing & Validation ‚Äî load test, verify data integrity, handle edge cases, ensure business logic works correctly.

Downtime / Migration Strategy ‚Äî plan whether to do a full cut-over, phased migration, or hybrid approach, account for data changes during migration.

üí° Conclusion

Yes ‚Äî migrating a database between engines is possible and often done. But it is seldom trivial. Because of differences in data types, SQL dialects, stored-procedure languages, database features, indexing and performance behavior ‚Äî a migration usually involves careful planning, manual rewriting of schema and code, extensive testing, and likely reworking of parts of the application.
